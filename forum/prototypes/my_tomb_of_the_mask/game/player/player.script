
-- Простая карта проходимости (0 - стена, 1 - проход)
-- local passability = {
-- 	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
-- 	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
-- 	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
-- 	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
-- 	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
-- 	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
-- 	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
-- 	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
-- 	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
-- 	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
-- 	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
-- 	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
-- 	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
-- 	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
-- 	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
-- 	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
-- }

local TILE_SIZE = 16 -- Размер одного тайла (ячейки) в пикселях. Используется для вычисления позиции в игровом мире.

-- Таблица проходимости карты. 1 – проходимо, 0 – препятствие.
-- Каждая внутренняя таблица – строка (по Y), каждый элемент – столбец (по X).
local passability = {
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
	{1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0},
	{1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0},
	{1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0},
	{1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0},
	{1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0},
	{1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0},
	{1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0},
	{1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0},
	{1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0},
	{1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,0},
	{1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0},
	{1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0},
	{1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
}

-- Функция проверки проходимости ячейки по координатам x, y (индексы тайлов)
local function is_passable(x, y)
	-- Проверка, что координаты не выходят за границы массива и что ячейка проходима (значение 1)
	if y > 0 and y <= #passability and x > 0 and x <= #passability[1] then
		print("Проход возможен!")
		return passability[y][x] == 1 -- возвращаем true если проходимо
	end
	print("Проход запрещён!")
	return false -- вне карты или непроходимо
end

-- Функция инициализации (вызывается при старте объекта)
function init(self)
	msg.post(".", "acquire_input_focus") -- получаем фокус ввода клавиатуры для объекта

	-- Задаём начальные координаты игрока в терминах индексов тайлов (1,1 - верхний левый угол)
	self.tile_x = 1
	self.tile_y = 1
	self.moving = false -- флаг, обозначающий, что игрок сейчас не движется

	-- Рассчитываем позицию по пикселям так, чтобы объект стоял по центру тайла
	local start_pos = vmath.vector3(
	self.tile_x * TILE_SIZE + TILE_SIZE / 2,
	self.tile_y * TILE_SIZE + TILE_SIZE / 2,
	0
)	
go.set_position(start_pos) -- выставляем позицию игрового объекта
end

-- Функция движения объекта с вектором смещения input_x, input_y (в терминах тайлов)
local function move(self, input_x, input_y)
	if self.moving then
		return -- если уже движемся, игнорируем новые команды движения
	end

	-- Вычисляем координаты целевой ячейки с учётом направления движения
	local next_tile_x = self.tile_x + input_x 
	local next_tile_y = self.tile_y + input_y

	-- Рассчитываем позицию цели в мировых координатах (пикселях)
	local target_pos = vmath.vector3(
	next_tile_x * TILE_SIZE + TILE_SIZE / 2,
	next_tile_y * TILE_SIZE + TILE_SIZE / 2,
	0
	)

	-- Сохраняем направление движения для возможного повторного шага
	self.dir = { dx = input_x, dy = input_y }
	self.moving = true -- отмечаем, что начало движения

	-- Проверяем, проходима ли целевая ячейка
	if is_passable(next_tile_x, next_tile_y) then
		local object = self
		-- Запускаем анимацию перемещения к цели (позиция меняется плавно за 0.01 сек)
		go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, target_pos, go.EASING_LINEAR, 0.01, 0, function()
				-- По завершении анимации обновляем позицию в тайлах и снимаем флаг движения
				object.tile_x = next_tile_x
				object.tile_y = next_tile_y
				self.moving = false
				-- Если сохранилось направление, рекурсивно вызываем move для продолжения движения в том же направлении
				if object.dir then
					move(object, object.dir.dx, object.dir.dy)
				end
			end)
		else
		-- Если ход невозможен (препятствие или за пределами карты), отменяем движение
		self.moving = false
		self.dir = nil
	end
	
end

function on_input(self, action_id, action)
	-- Обрабатываем событие ввода, например, нажатия клавиш
	-- Проверяем, что клавиша была именно нажата (pressed)
	if action.pressed then
		-- В зависимости от идентификатора действия вызываем движение

		if action_id == hash("left") then
			print("Влево!")         -- Вывод в консоль для отладки направления
			move(self, -1, 0)       -- Движение на один тайл влево по оси X

		elseif action_id == hash("right") then
			print("Вправо!")
			move(self, 1, 0)        -- Движение на один тайл вправо

		elseif action_id == hash("up") then
			print("Вверх!")
			move(self, 0, 1)        -- Движение на один тайл вверх по оси Y

		elseif action_id == hash("down") then
			print("Вниз!")
			move(self, 0, -1)       -- Движение на один тайл вниз
		end
	end
end